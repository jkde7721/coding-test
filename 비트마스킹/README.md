## Bit Masking

**이진법을 통해 하나의 숫자를 boolean 배열로 표현 가능**

ex. `3, 0번째 요소가 포함` = `3, 0번째 비트가 ON` = `1001b` → 숫자 9로 표현 가능

<br/>

### 비트 연산자

| 연산자 | 설명                                           | 예                       |
| ------ | ---------------------------------------------- | ------------------------ |
| `&`    | 비트 단위 AND                                  | `2(10) & 3(11) = 2(10)`  |
| `\|`   | 비트 단위 OR                                   | `2(10) \| 3(11) = 3(11)` |
| `^`    | 비트 단위 XOR (비트 단위 더하기 연산처럼 동작) | `2(10) ^ 3(11) = 1(01)`  |
| `~`    | 비트 반전                                      | `~2(10) = 1(01)`         |
| `<<`   | left logical shift, 비트 왼쪽으로 이동         | `a << b = a * 2 ^ b`     |
| `>>`   | right logical shift, 비트 오른쪽으로 이동      | `a >> b = a * (1/2) ^ b` |

- 음수 표현 (2의 보수)
  - 어떤 양수 `value`에 대한 음수 `-value`는 `~value + 1`로 표현
  - 원래 수 비트 반전(`~` 연산) 후 → 1을 더함(`+1`)
  - ex. `5(0101)` → `~5 = 1010` → `~5 + 1 = 1011`

<br/>

### 비트 연산자 활용

| 활용                           | 연산식                |
| ------------------------------ | --------------------- |
| idx번째만 비트 켜기            | `S \|= (1 << idx)`    |
| idx번째만 비트 끄기            | `S &= ~(1 << idx)`    |
| idx번째만 비트 반전            | `S ^= (1 << idx)`     |
| idx번째 비트가 켜져있는지 확인 | `if (S & (1 << idx))` |
| 크기가 n인 모든 비트 켜기      | `(1 << n) - 1`        |
| 최하위 1 비트 찾기             | `idx = (S & -S)`      |

> x는 0 또는 1의 1-bit 수

- **idx번째만 비트 켜기** (= 원소 추가)

  - 0과 OR 연산의 결과는 항상 자기 자신 `x | 0 = x`
  - 1과 OR 연산의 결과는 항상 1 `x | 1 = 1`
  - 1을 idx번 만큼 left shift하고 OR 연산 → idx번째 제외 나머지 비트들은 0과 OR 연산하여 자기 자신 / idx번째 비트는 1과 OR 연산하여 항상 1(ON)

- **idx번째만 비트 끄기** (= 원소 삭제)

  - 0과 AND 연산의 결과는 항상 0 `x & 0 = 0`
  - 1과 AND 연산의 결과는 항상 자기 자신 `x & 1 = x`
  - 1을 idx번 만큼 left shift하고 모든 비트 반전 후 AND 연산 → idx번째 제외 나머지 비트들은 1과 AND 연산하여 자기 자신 / idx번째 비트는 0과 AND 연산하여 항상 0(OFF)

- **idx번째만 비트 반전** (= 원소 토글)

  - 0과 XOR 연산의 결과는 항상 자기 자신 `x ^ 0 = x`
  - 1과 XOR 연산의 결과는 항상 반전된 자기 자신 `x ^ 1 = ~x`
  - 1을 idx번 만큼 left shift하고 XOR 연산 → idx번째 제외 나머지 비트들은 0과 XOR 연산하여 자기 자신 / idx번째 비트는 1과 XOR 연산하여 비트 반전

- **idx번째 비트가 켜져있는지 확인** (= 원소 포함 여부 확인)

  - 1을 idx번 만큼 left shift하고 AND 연산 → idx번째 제외 나머지 비트들은 0과 AND 연산하여 항상 0 / idx번째 비트는 1과 AND 연산하여 자기 자신, 즉 idx번째 비트가 1이면 if문 조건식 `true`, 0이면 `false`

- **크기가 n인 모든 비트 켜기**

  - 1을 n번 만큼 shift → 크기가 n + 1이면서 MSB만 1이고 나머지 하위 n개의 비트들은 0 ex. `1 << 3 = 1000b`
  - 이 상태에서 1을 빼주면 크기가 n이면서 모든 비트가 1 ex. `(1 << 3) - 1 = 111b`

- **최하위 1 비트 찾기**
  - ex. 10100의 최하위 1 비트 값은? 10**1**00으로 2번째 비트, 즉 `4(00100)`
  - 원래 숫자와 해당 숫자의 음수값을 AND 연산하여 구함
  - 펜윅트리 구현에 활용

<br/>

### 비트마스킹을 이용한 경우의 수

- **비트마스킹**: 컴퓨터는 내부적으로 모든 값을 이진수로 표현 → 이와 같은 특성을 이용해 정수의 이진수 표현을 자료구조로 사용하는 기법
- 즉 **boolean 배열의 역할**을 하는 **하나의 숫자**를 **비트 연산자**를 사용하여 탐색, 수정 등의 작업을 하는 것
- 더 빠른 수행 시간, 더 간결한 코드, 더 적은 메모리 사용 효과
- ex. 5개의 물건 A, B, C, D, E에서 물건을 사는 경우의 수 = 2(물건을 사거나 / 사지 않거나) ^ 5 → 비트마스킹으로 표현 가능
  - `물건 A, B ... D` → `0, 1 ... 4번째 비트`에 대응
  - 각 비트 값이 1이면 해당 물건을 삼, 0이면 사지 않음을 가정
  - 가능한 비트 case: 00000, 00001, 00010 ... 11111

```c++
const char obj[5] = {'A', 'B', 'C', 'D', 'E'};
//가능한 비트 case 탐색
for (int i = 0; i < (1 << 5); i++) {
    cout << "Buy ";
    for (int j = 0; j < 5; j++) {
        if (i & (1 << j)) cout << obj[j] << ' '; //해당 물건을 사는지 사지 않는지 확인
    }
    cout << '\n';
}
```

```text
실행 결과 (물건이 3개인 경우)
Buy
Buy A
Buy B
Buy A B
Buy C
Buy A C
Buy B C
Buy A B C
```

→ 3C0, 3C1, 3C2, 3C3과 같은 조합의 모든 경우를 for문으로 탐색 가능

<br/>

**대표 문제** [1062번 가르침](https://www.acmicpc.net/problem/1062), [2098번 외판원 순회](https://www.acmicpc.net/problem/2098)

```c++
//1062번 가르침
#include <iostream>
using namespace std;

int n, k, word[50];
string str;

//mask는 해당 인덱스의 알파벳 배웠는지 여부를 저장하는 boolean 배열 역할
int go(int idx, int cnt, int mask) {
    if (cnt == k + 1) return 0;
    if (idx == 26) {
        int tmp = 0;
        for (int i = 0; i < n; i++) {
            if ((word[i] & mask) == word[i]) tmp++; //해당 단어를 읽을 수 있으면
        }
        return tmp;
    }
    int ret = go(idx + 1, cnt + 1, mask | (1 << idx)); //해당 인덱스의 알파벳을 배움
    if (idx != 'a' - 'a' && idx != 'c' - 'a' && idx != 'i' - 'a' && idx != 'n' - 'a' && idx != 't' - 'a') {
        ret = max(ret, go(idx + 1, cnt, mask)); //해당 인덱스의 알파벳을 배우지 않음
    }
    return ret;
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) {
        cin >> str;
        for (char c : str) word[i] |= 1 << (c - 'a'); //해당 단어를 읽기 위해 알아야 하는 알파벳 마스킹
    }
    cout << go(0, 0, 0) << '\n';
    return 0;
}
```

- 각 알파벳 `a, b ... z` → `0, 1 ... 25번째 비트`에 대응

- 특정 단어의 알파벳 구성을 나타내는 정수와 배운 알파벳 정보를 나타내는 정수를 AND 연산하여 해당 단어를 읽을 수있는지 판단
- ex. 특정 단어가 알파벳 a, b, c로 구성되어 있을 때 정수 word는 `7(0111)`,
  배운 알파벳이 a, b, c, d일 때 정수 mask는 `15(1111)` → `7 & 15 = 7(0111)`로 결과가 word와 같으므로 읽을 수 있음

  반면 배운 알파벳이 a, b 뿐이면 mask는 `3(0011)` → `7 & 3 = 3(0011)`로 결과가 word와 같지 않으므로 읽을 수 없음

<br/>

### 숫자에서 1인 비트 count하는 방법

- 더 자세한 내용 [참고](https://blog.naver.com/jinhan814/222540111549)

```c++
//직접 count
int cnt = 0, n = 11;
for (; n > 0; n >>= 1) {
    if (n & 1) cnt++; //LSB가 1이면 count
}
cout << cnt << '\n';

//c++ 내장 함수 사용
cout << __builtin_popcount(n) << '\n'; //숫자 n의 1인 비트 개수 반환
```

<br/>

> boolean 배열을 표현하는 int형 정수 범위가 약 10억이므로 가능한 N(ex. 물건의 수)의 최대 크기는 31, 즉 N이 31 보다 크면 비트마스킹 불가능
